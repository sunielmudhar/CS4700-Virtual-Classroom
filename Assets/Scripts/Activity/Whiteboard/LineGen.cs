using Photon.Pun;
using UnityEngine;
using System.IO;
using System.Collections.Generic;

public class LineGen : MonoBehaviour
{
    /// <summary>
    /// This script file works by generating a line that has been created client side, and then ask each other client to generate the same line
    /// with the sent coordinates. Assigns each generated line a reference code to be tracked, and stores it in a list to be updated.
    /// Using a list and line reference allows multiple clients to draw at the same time 
    /// </summary>

    [SerializeField] public GameObject linePrefab, participant, line;
    [SerializeField] public Line currentLine;
    [SerializeField] List<Line> currentLineList = new List<Line>();
    [SerializeField] static bool bl_CanDraw = false;
    PhotonView PV;

    Vector3 mousePosVec;
    RaycastHit hit;

    void Start()
    {
        PV = GetComponent<PhotonView>();
    }

    // Update is called once per frame
    void Update()
    {
        if (bl_CanDraw)
        {
            participant = GameObject.Find("CurrentParticipant");

            if (Input.GetMouseButtonDown(0) && participant.tag.Equals("Student"))
            {
                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);    //Generate a ray from the current camera

                if (Physics.Raycast(ray, out hit) && hit.collider.gameObject.tag.Equals("Plane"))   //Check to see if the raycast is hitting the plane
                {
                    line = Instantiate(linePrefab, hit.point, Quaternion.identity); //Create a line client side
                    Line newLine = line.GetComponent<Line>();
                    newLine.GenerateRef();  //Generate a reference for this newly created line
                    currentLineList.Add(newLine);   //Add the line to a list of currently active lines
                    currentLine = newLine;
                    PV.RPC("drawFunction", RpcTarget.Others, hit.point, newLine.GetLineRef());  //Ask other clients connected to the classroom to draw this line and assign it the reference code generated by this client
                }
            }

            if (currentLine != null && Input.GetMouseButton(0))
            {
                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);

                if (Physics.Raycast(ray, out hit))
                {
                    mousePosVec = hit.point;
                    PV.RPC("helperFunction", RpcTarget.All, "notNullActiveLine", mousePosVec, currentLine.GetLineRef());    //Find the line with this reference and update it with the new positions
                }

            }

            if (Input.GetMouseButtonUp(0))
            {
                PV.RPC("helperFunction", RpcTarget.All, "mouseUp", null, currentLine.GetLineRef()); //Find the line with this reference and stop updating it
            }

            if (Input.GetMouseButton(1))
            {
                var Ray = Camera.main.ScreenPointToRay(Input.mousePosition);
                RaycastHit hit;

                if (Physics.Raycast(Ray, out hit) && hit.collider.gameObject.tag.Equals("Line"))
                {
                    PhotonNetwork.Destroy(hit.collider.gameObject);
                }
            }
        }
    }

    //Used by other clients to instantiate a line drawn by another client
    [PunRPC]
    public void drawFunction(Vector3 hitPoint, int lineRef)
    {
        line = Instantiate(linePrefab, hitPoint, Quaternion.identity);
        Line newLine = line.GetComponent<Line>();
        newLine.SetLineRef(lineRef);    //Assign sent line the reference recieved by the sending client
        currentLineList.Add(newLine);   //Store sent line in this clients list
    }

    //Helper function checks to see if the participant is still drawing the same line, or has stopped
    [PunRPC]
    public void helperFunction(string action, Vector3 mousePosVec, int lineRef)
    {
        Line lineToRemove = null;

        //Find the line to be updated from this clients line list
        foreach (Line line in currentLineList)
        {
            //Check if the sent line reference equals the current in the list
            if (line.GetLineRef() == lineRef)
            {
                Line activeLine = line;

                if (action.Equals("mouseUp"))
                {
                    activeLine = null;  //Stop updating this line
                    lineToRemove = line;
                    break;
                }
                else if (action.Equals("notNullActiveLine"))
                {
                    activeLine.UpdateLine(mousePosVec); //Continue updating this line
                    break;
                }
            }
        }

        currentLineList.Remove(lineToRemove);   //Remove line from list as it is no longer updated
    }

    public static void CanDraw(bool state)
    {
        bl_CanDraw = state;
    }
}
